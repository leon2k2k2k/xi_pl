// this works
let asldfj  = lambda |T: Type, succ: T -> T| succ 

// this works
let oasdlfj = lambda |T : Type, zero: T, succ: T -> T| succ zero 


// this also works.
let zero1 : Pi |T : Type|  T -> (T -> T) -> T  = lambda | T : Type, zero : T, succ: T -> T| zero

// this works.
let hello =  Pi| T : Type| T -> (T -> T) -> T 


// this does work
let zero = lambda | T : Type, zero : T, succ: T -> T| zero


// this DOESN'T work!!!!!!!!!!!!!!!!!!!!!!!! Probably a type inference issue
let one : Pi| T: Type | T -> (T -> T) -> T = lambda | T, zero, succ| (succ zero)



// This also DOESN'T work!!!!!!!!!!!!!!!!!!!!!
let ok =  lambda |T : Type, f : Type -> T| f T
// There is something wrong with app and variable binding. Maybe we have fixed it.


// problem with app, and variables out of scope.

let id = lambda |T : Type, t : T| t

let id : Pi |T: Type | T -> T = lambda |T : Type, t : T| t



val 5
