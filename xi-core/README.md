# xi-core

This crate contains the core data structures of Aplite: a `Judgment`, as well as some surrounding helper functions.

The variable binding convention in use is locally nameless. Free variables are globally unique identifiers, given by the type `VarUuid`, generated by incrementing from 0.

If a variable is bound, then it is represented as a De Bruijn index. As you recurse into judgements, bound variables get instantiated with new free variables. This was chosen after too many variable binding bugs were solved by not dealing with bound variables correctly in intermediate data structures.

This is implemneted by having a Judgment be recursive with a ScopedJudgment, which represents a Judgment with a free variable.

The API is as follows:

```rust
// binds the given free variable in the judgment, also known as abstract
bind: Judgment -> VarUuid -> ScopedJudgment
// takes instances of the bound variable and makes them free again
unbind: ScopedJudgment -> (Judgment, VarUuid)
// substitute the given judgment in the outermost bound variable
instantiate: ScopedJudgment -> Judgment -> Judgment
```

The core type theory is the Calculus of Constructions, with no extensions (so no primitive inductive types). The main difference between our presentation and the standard presentation is that we use `Type` where others would use `Prop` and have no real representation of the CoC "Type". We do not assume that any two elements of a `Prop` are equal, though our theory is consistent with it.

Judgment has a type parameters, one to represent the type of primitives inside the Judgment. The idea is that all of judgment code is paramatrized by what type of constants are inside the type theory. If you want inductive types, it shouldn't require changing any existing code, just changing the `T` in `Judgment<T>`.

The API of Judgment is as follows

``` rust
// returns true if the judgment is "big", usually meaning that it lands in  -> U
has_type: Judgment -> bool
// returns the type of the Judgment, panics if has_type returns false
type_of: Judgment -> Judgment
// the judgement corresponding to Type
u: Judgment
// takes the type,, and the body
pi: Judgment -> ScopedJudgment -> Judgment
// takes the type,, and the body
lam: Judgment -> ScopedJudgment -> Judgment
// constructor for a free variable
free: VarUuid -> Judgment -> Judgment
// constructs a primitive, takes its type, which is stored in the Judgment
prim: T -> Judgment -> Judgment
// and last but not least
app: Judgment -> Judgment -> Judgmentt
```

All these functions do type checking. There are some `_unchecked` versions of `pi` and `app`. There's also metadata, but that's a complete failure. You can ignore that.

Inside `nbe.rs` there is an implementation of normalization by evaluation. It works fine, and is used for type checking. 

There is a `define_prim` function, which is the monadic bind operation on `Judgment`. It has type

```
define_prim: Judgment<T> -> (T -> Judgent<T> -> Judgment<S>) -> Judgment<S>
```

The intended semantics is that it recurses to the leaves, where it applies the function applying the element of `T` and its type. Type information is attached, in case you want one `T` to not uniquely identify a type.

Notice how there is no constructor for bound variables. Those can only be made through `bind`.

Ideally `type_of` would be made more type safe somehow, but I don't think rust has a strong enough type theory. I don't think anything has a good enough type theory for it.

There is a pretty printer in `prettify.rs` There's not too much to say about it.
